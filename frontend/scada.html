<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>kuNNA - SCADA Monitor</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        :root {
            --bg-primary: #0f0f23;
            --bg-secondary: #1a1a2e;
            --bg-card: #16213e;
            --accent-primary: #00d4ff;
            --accent-secondary: #a855f7;
            --text-primary: #ffffff;
            --text-secondary: #94a3b8;
            --border-color: #2d3748;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow: hidden;
        }

        .toolbar {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            padding: 16px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .toolbar h1 {
            font-size: 1.8em;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .toolbar-actions {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: var(--bg-card);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.3s;
        }

        .checkbox-container:hover {
            border-color: var(--accent-primary);
        }

        .checkbox-container input[type="checkbox"] {
            cursor: pointer;
            width: 18px;
            height: 18px;
            accent-color: var(--accent-primary);
        }

        .checkbox-container label {
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 500;
            color: var(--text-secondary);
            user-select: none;
        }

        .btn {
            padding: 10px 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-card);
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Inter', sans-serif;
            font-weight: 500;
            text-decoration: none;
        }

        .btn:hover {
            background: var(--bg-secondary);
            border-color: var(--accent-primary);
            transform: translateY(-2px);
        }

        .stats {
            display: flex;
            gap: 12px;
        }

        .stat {
            padding: 8px 16px;
            background: var(--bg-card);
            border-radius: 8px;
            font-size: 0.9em;
        }

        .stat-value {
            font-weight: 700;
            color: var(--accent-primary);
        }

        .container {
            display: flex;
            height: calc(100vh - 70px);
        }

        .sidebar {
            width: 300px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            padding: 20px;
            overflow-y: auto;
        }

        .sidebar h2 {
            font-size: 1.2em;
            margin-bottom: 16px;
            color: var(--text-secondary);
        }

        .group-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .group-item {
            padding: 12px;
            background: var(--bg-card);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.3s;
        }

        .group-item:hover {
            border-color: var(--accent-primary);
            transform: translateX(4px);
        }

        .group-item.active {
            border-color: var(--accent-primary);
            background: var(--bg-primary);
        }

        .group-name {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .group-services {
            font-size: 0.85em;
            color: var(--text-secondary);
        }

        .canvas {
            flex: 1;
            position: relative;
            background: var(--bg-primary);
            background-image: 
                repeating-linear-gradient(0deg, transparent, transparent 49px, var(--border-color) 49px, var(--border-color) 50px),
                repeating-linear-gradient(90deg, transparent, transparent 49px, var(--border-color) 49px, var(--border-color) 50px);
        }

        #topology-svg {
            width: 100%;
            height: 100%;
        }

        .node {
            cursor: move;
        }

        .node-circle {
            transition: all 0.3s;
        }

        .node:hover .node-circle {
            filter: brightness(1.3);
            r: 45;
        }

        .node-running {
            fill: var(--success);
            filter: drop-shadow(0 0 10px var(--success));
        }

        .node-stopped {
            fill: var(--danger);
            filter: drop-shadow(0 0 10px var(--danger));
        }

        .node-paused {
            fill: var(--warning);
            filter: drop-shadow(0 0 10px var(--warning));
        }

        .node-label {
            fill: var(--text-primary);
            font-size: 12px;
            font-weight: 600;
            text-anchor: middle;
            pointer-events: none;
        }

        .node-remote-badge {
            fill: var(--text-primary);
            font-size: 10px;
            font-weight: 500;
            text-anchor: middle;
            pointer-events: none;
        }

        .node-icon {
            font-size: 24px;
            text-anchor: middle;
            pointer-events: none;
        }

        .link {
            stroke: var(--accent-primary);
            stroke-width: 3;
            stroke-opacity: 0.4;
            fill: none;
            transition: stroke-opacity 0.3s;
        }

        .link-particle {
            pointer-events: none;
        }

        .status-badge {
            stroke: var(--bg-card);
            stroke-width: 2;
            transition: fill 0.5s;
        }

        .node {
            cursor: move;
            transition: opacity 0.3s;
        }

        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 16px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--accent-primary);
            border-radius: 4px;
        }

        .node-control-panel {
            position: absolute;
            top: 80px;
            right: 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            min-width: 300px;
            max-width: 400px;
            display: none;
            z-index: 1000;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        .node-control-panel.visible {
            display: block;
        }

        .control-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-color);
        }

        .control-panel-title {
            font-size: 1.2em;
            font-weight: 700;
        }

        .close-panel {
            background: none;
            border: none;
            color: var(--text-secondary);
            font-size: 1.5em;
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 6px;
            transition: all 0.3s;
        }

        .close-panel:hover {
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        .control-panel-info {
            margin-bottom: 16px;
        }

        .control-panel-info p {
            margin: 8px 0;
            font-size: 0.9em;
            color: var(--text-secondary);
        }

        .control-panel-info strong {
            color: var(--text-primary);
        }

        .control-panel-actions {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-btn {
            padding: 12px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-card);
            color: var(--text-primary);
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s;
            font-family: 'Inter', sans-serif;
        }

        .control-btn:hover {
            transform: translateY(-2px);
        }

        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .control-btn.start:hover:not(:disabled) {
            background: #10b981;
            border-color: #10b981;
        }

        .control-btn.stop:hover:not(:disabled) {
            background: #f59e0b;
            border-color: #f59e0b;
        }

        .control-btn.restart:hover:not(:disabled) {
            background: #3b82f6;
            border-color: #3b82f6;
        }
    </style>
</head>
<body>
    <div class="toolbar">
        <h1>üéØ kuNNA SCADA Monitor</h1>
        <div class="stats">
            <div class="stat">
                Total: <span class="stat-value" id="total-services">0</span>
            </div>
            <div class="stat">
                Activos: <span class="stat-value" id="active-services">0</span>
            </div>
            <div class="stat">
                Grupos: <span class="stat-value" id="total-groups">0</span>
            </div>
        </div>
        <div class="toolbar-actions">
            <div class="checkbox-container" title="Ocultar el agente kunna para simplificar la visualizaci√≥n">
                <input type="checkbox" id="showAgentCheckbox" checked onchange="toggleAgentVisibility()">
                <label for="showAgentCheckbox">Mostrar kunna-agent</label>
            </div>
            <a href="/" class="btn">üìä Dashboard</a>
            <a href="/servers.html" class="btn" style="background: linear-gradient(135deg, #7c3aed, #a855f7);">üñ•Ô∏è Servidores</a>
            <button class="btn" onclick="refreshTopology()">üîÑ Actualizar</button>
        </div>
    </div>

    <div class="container">
        <div class="sidebar">
            <h2>Grupos de Aplicaciones</h2>
            <div class="group-list" id="group-list">
                <!-- Se llena din√°micamente -->
            </div>
        </div>

        <div class="canvas">
            <svg id="topology-svg"></svg>
            
            <!-- Panel de control de contenedor -->
            <div class="node-control-panel" id="controlPanel">
                <div class="control-panel-header">
                    <div class="control-panel-title" id="panelTitle">Control de Contenedor</div>
                    <button class="close-panel" onclick="closeControlPanel()">√ó</button>
                </div>
                <div class="control-panel-info" id="panelInfo">
                    <!-- Se llena din√°micamente -->
                </div>
                <div class="control-panel-actions" id="panelActions">
                    <!-- Se llena din√°micamente -->
                </div>
            </div>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: var(--success);"></div>
                    <span>Running</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: var(--danger);"></div>
                    <span>Stopped</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: var(--warning);"></div>
                    <span>Paused</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const BACKEND_HOST = window.location.hostname;
        const BACKEND_HTTP = `${window.location.protocol}//${BACKEND_HOST}:8000`;
        const API_URL = `${BACKEND_HTTP}/api`;
        const WS_SCHEME = window.location.protocol === 'https:' ? 'wss' : 'ws';
        const WS_URL = `${WS_SCHEME}://${BACKEND_HOST}:8000/ws/traffic`;
        let topologyData = null;
        let simulation = null;
        let svg = null;
        let nodes = [];
        let links = [];
        let nodeElements = null;
        let linkElements = null;
        let ws = null;
        let trafficQueue = [];
        let showAgent = true; // Control de visibilidad del agente

        async function loadTopology() {
            try {
                const response = await fetch(`${API_URL}/topology`);
                const newData = await response.json();
                
                // Actualizar estad√≠sticas
                document.getElementById('total-services').textContent = newData.total_services;
                document.getElementById('active-services').textContent = newData.active_services;
                document.getElementById('total-groups').textContent = newData.groups.length;
                
                // Primera carga - crear gr√°fico
                if (!topologyData) {
                    topologyData = newData;
                    renderGroups();
                    initializeTopology();
                } else {
                    // Solo actualizar estados sin recrear
                    updateNodeStates(newData);
                    topologyData = newData;
                }
            } catch (error) {
                console.error('Error loading topology:', error);
            }
        }

        function renderGroups() {
            const groupList = document.getElementById('group-list');
            groupList.innerHTML = topologyData.groups.map((group, index) => `
                <div class="group-item ${index === 0 ? 'active' : ''}" onclick="focusGroup('${group.id}')">
                    <div class="group-name">${group.name}</div>
                    <div class="group-services">${group.services.length} servicios</div>
                </div>
            `).join('');
        }

        function toggleAgentVisibility() {
            showAgent = document.getElementById('showAgentCheckbox').checked;
            
            // Recargar topolog√≠a si ya est√° cargada
            if (topologyData) {
                initializeTopology();
            }
        }

        function updateNodeStates(newData) {
            if (!nodeElements) return;

            // Crear mapa de estados nuevos
            const statusMap = {};
            newData.groups.forEach(group => {
                group.services.forEach(service => {
                    statusMap[service.id] = service.status;
                });
            });

            // Actualizar clases de estado en los c√≠rculos
            nodeElements.selectAll('circle')
                .attr('class', d => {
                    const newStatus = statusMap[d.id] || d.status;
                    d.status = newStatus; // Actualizar el dato
                    return `node-circle node-${newStatus}`;
                });
        }

        function initializeTopology() {
            svg = d3.select('#topology-svg');
            const width = svg.node().getBoundingClientRect().width;
            const height = svg.node().getBoundingClientRect().height;

            svg.selectAll('*').remove();

            // Preparar datos para D3
            nodes = [];
            links = [];

            // Crear nodos por servicio (filtrar kunna-agent si est√° deshabilitado)
            topologyData.groups.forEach((group, groupIndex) => {
                group.services.forEach((service, serviceIndex) => {
                    // Filtrar kunna-agent si showAgent es false
                    if (!showAgent && service.name === 'kunna-agent') {
                        return; // Saltar este nodo
                    }
                    
                    nodes.push({
                        id: service.id,
                        name: service.name,
                        status: service.status,
                        icon: service.icon,
                        group: group.id,
                        groupIndex: groupIndex,
                        networks: service.networks,
                        is_remote: service.is_remote || false,
                        server_hostname: service.server_hostname,
                        container_id: service.container_id  // ‚Üê Agregar container_id para habilitar control
                    });
                });
            });

            // Crear enlaces SOLO entre servicios que comparten red
            // (excluir enlaces de/hacia kunna-agent si est√° oculto)
            topologyData.connections.forEach(conn => {
                // Si showAgent es false, filtrar enlaces que incluyan kunna-agent
                if (!showAgent) {
                    const sourceNode = topologyData.groups
                        .flatMap(g => g.services)
                        .find(s => s.id === conn.source);
                    const targetNode = topologyData.groups
                        .flatMap(g => g.services)
                        .find(s => s.id === conn.target);
                    
                    if ((sourceNode && sourceNode.name === 'kunna-agent') || 
                        (targetNode && targetNode.name === 'kunna-agent')) {
                        return; // Saltar este enlace
                    }
                }
                
                links.push({
                    source: conn.source,
                    target: conn.target,
                    network: conn.network
                });
            });

            // Crear simulaci√≥n de fuerza con posiciones iniciales fijas
            simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(200))
                .force('charge', d3.forceManyBody().strength(-500))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(70))
                .force('x', d3.forceX(width / 2).strength(0.05))
                .force('y', d3.forceY(height / 2).strength(0.05));

            // Dibujar enlaces primero (debajo de los nodos)
            const linkGroup = svg.append('g');
            linkElements = linkGroup.selectAll('g')
                .data(links)
                .enter().append('g')
                .attr('class', 'link-group');

            // L√≠nea base del enlace
            linkElements.append('path')
                .attr('class', 'link')
                .attr('stroke', '#00d4ff')
                .attr('stroke-width', 3)
                .attr('stroke-opacity', 0.4)
                .attr('fill', 'none');

            // C√≠rculo animado que viaja por el enlace (petici√≥n simulada - ser√° reemplazado por real)
            linkElements.append('circle')
                .attr('class', 'link-particle')
                .attr('r', 4)
                .attr('fill', '#00d4ff')
                .attr('opacity', 0)
                .style('filter', 'drop-shadow(0 0 4px #00d4ff)');

            // NO iniciar animaci√≥n simulada - solo tr√°fico real
            // startParticleAnimation(); // ‚Üê DESHABILITADO

            // Dibujar nodos
            nodeElements = svg.append('g')
                .selectAll('g')
                .data(nodes)
                .enter().append('g')
                .attr('class', 'node')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended))
                .on('click', onNodeClick);

            // C√≠rculos de nodos con estado
            nodeElements.append('circle')
                .attr('class', d => `node-circle node-${d.status}`)
                .attr('r', 45);

            // Iconos
            nodeElements.append('text')
                .attr('class', 'node-icon')
                .attr('dy', 10)
                .style('font-size', '28px')
                .text(d => d.icon);

            // Etiquetas
            nodeElements.append('text')
                .attr('class', 'node-label')
                .attr('dy', 70)
                .text(d => d.name.length > 15 ? d.name.substring(0, 15) + '...' : d.name);

            // Badge remoto (si aplica)
            nodeElements.filter(d => d.is_remote)
                .append('text')
                .attr('class', 'node-remote-badge')
                .attr('dy', 85)
                .style('fill', '#a855f7')
                .text(d => `üåê ${d.server_hostname || ''}`);

            // Badge de estado
            nodeElements.append('circle')
                .attr('class', 'status-badge')
                .attr('cx', 30)
                .attr('cy', -30)
                .attr('r', 8)
                .attr('fill', d => getStatusColor(d.status));

            // Actualizar posiciones en cada tick
            simulation.on('tick', updatePositions);

            // Detener simulaci√≥n despu√©s de un tiempo para estabilizar
            setTimeout(() => {
                simulation.alpha(0);
            }, 3000);
        }

        function startParticleAnimation() {
            function animate() {
                linkElements.selectAll('.link-particle')
                    .attr('opacity', 0)
                    .transition()
                    .duration(0)
                    .attr('opacity', 1)
                    .transition()
                    .duration(2000)
                    .ease(d3.easeLinear)
                    .attrTween('transform', function(d) {
                        return function(t) {
                            const source = d.source;
                            const target = d.target;
                            if (!source || !target) return '';
                            
                            const x = source.x + (target.x - source.x) * t;
                            const y = source.y + (target.y - source.y) * t;
                            return `translate(${x},${y})`;
                        };
                    })
                    .transition()
                    .duration(0)
                    .attr('opacity', 0);
                
                setTimeout(animate, 2500);
            }
            
            // Iniciar con delay aleatorio para cada enlace
            linkElements.each(function(d, i) {
                setTimeout(() => {
                    d3.select(this).select('.link-particle').call(() => animate());
                }, i * 300);
            });
        }

        function updatePositions() {
            // Actualizar enlaces
            linkElements.select('path')
                .attr('d', d => {
                    if (!d.source || !d.target) return '';
                    const dx = d.target.x - d.source.x;
                    const dy = d.target.y - d.source.y;
                    const dr = Math.sqrt(dx * dx + dy * dy) * 1.5;
                    return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
                });

            // Actualizar nodos
            nodeElements.attr('transform', d => `translate(${d.x},${d.y})`);
        }

        function getStatusColor(status) {
            const colors = {
                'running': '#10b981',
                'exited': '#ef4444',
                'paused': '#f59e0b'
            };
            return colors[status] || '#6b7280';
        }

        function onNodeClick(event, d) {
            event.stopPropagation();
            
            // Highlight del nodo y sus conexiones
            nodeElements.style('opacity', n => {
                return n === d || isConnected(n, d) ? 1 : 0.3;
            });

            linkElements.style('opacity', l => {
                return l.source === d || l.target === d ? 1 : 0.1;
            });

            // Mostrar panel de control
            showControlPanel(d);
        }

        function showControlPanel(node) {
            const panel = document.getElementById('controlPanel');
            const panelTitle = document.getElementById('panelTitle');
            const panelInfo = document.getElementById('panelInfo');
            const panelActions = document.getElementById('panelActions');
            
            // T√≠tulo
            panelTitle.textContent = node.name;
            
            // Informaci√≥n
            const statusColor = getStatusColor(node.status);
            const serverInfo = node.server_hostname ? `<p><strong>Servidor:</strong> ${node.server_hostname}</p>` : '';
            const networksInfo = node.networks && node.networks.length > 0 
                ? `<p><strong>Redes:</strong> ${node.networks.join(', ')}</p>` 
                : '';
            
            panelInfo.innerHTML = `
                <p><strong>Estado:</strong> <span style="color: ${statusColor}">${node.status.toUpperCase()}</span></p>
                <p><strong>ID:</strong> ${node.id}</p>
                ${serverInfo}
                ${networksInfo}
            `;
            
            // Botones de acci√≥n
            const isRunning = node.status === 'running';
            const containerId = node.container_id || (node.id && node.id.startsWith('remote-') ? node.id : null);
            panelActions.innerHTML = containerId ? `
                <button class="control-btn start" onclick="startContainerFromSCADA('${containerId}')" ${isRunning ? 'disabled' : ''}>
                    ‚ñ∂Ô∏è Iniciar
                </button>
                <button class="control-btn stop" onclick="stopContainerFromSCADA('${containerId}')" ${!isRunning ? 'disabled' : ''}>
                    ‚èπÔ∏è Detener
                </button>
                <button class="control-btn restart" onclick="restartContainerFromSCADA('${containerId}')">
                    üîÑ Reiniciar
                </button>
            ` : `<p style="opacity: 0.8; font-size: 12px; margin: 0;">Sin contenedor asociado (solo lectura)</p>`;
            
            panel.classList.add('visible');
        }

        function closeControlPanel() {
            const panel = document.getElementById('controlPanel');
            panel.classList.remove('visible');
            
            // Quitar highlight
            nodeElements.style('opacity', 1);
            linkElements.style('opacity', 1);
        }

        async function startContainerFromSCADA(containerId) {
            try {
                const response = await fetch(`${API_URL}/containers/${containerId}/start`, { 
                    method: 'POST' 
                });
                const data = await response.json();
                
                if (response.ok) {
                    alert('‚úÖ ' + data.message);
                    closeControlPanel();
                    await loadTopology();
                } else {
                    alert('‚ùå Error: ' + (data.detail || 'No se pudo iniciar el contenedor'));
                }
            } catch (error) {
                console.error('Error starting container:', error);
                alert('‚ùå Error al iniciar el contenedor');
            }
        }

        async function stopContainerFromSCADA(containerId) {
            if (!confirm('¬øEst√°s seguro de detener este contenedor?')) return;
            
            try {
                const response = await fetch(`${API_URL}/containers/${containerId}/stop`, { 
                    method: 'POST' 
                });
                const data = await response.json();
                
                if (response.ok) {
                    alert('‚úÖ ' + data.message);
                    closeControlPanel();
                    await loadTopology();
                } else {
                    alert('‚ùå Error: ' + (data.detail || 'No se pudo detener el contenedor'));
                }
            } catch (error) {
                console.error('Error stopping container:', error);
                alert('‚ùå Error al detener el contenedor');
            }
        }

        async function restartContainerFromSCADA(containerId) {
            if (!confirm('¬øEst√°s seguro de reiniciar este contenedor?')) return;
            
            try {
                const response = await fetch(`${API_URL}/containers/${containerId}/restart`, { 
                    method: 'POST' 
                });
                const data = await response.json();
                
                if (response.ok) {
                    alert('‚úÖ ' + data.message);
                    closeControlPanel();
                    await loadTopology();
                } else {
                    alert('‚ùå Error: ' + (data.detail || 'No se pudo reiniciar el contenedor'));
                }
            } catch (error) {
                console.error('Error restarting container:', error);
                alert('‚ùå Error al reiniciar el contenedor');
            }
        }

        function isConnected(node1, node2) {
            return links.some(l => 
                (l.source.id === node1.id && l.target.id === node2.id) ||
                (l.source.id === node2.id && l.target.id === node1.id)
            );
        }

        // Click en canvas para quitar highlight
        d3.select('#topology-svg').on('click', () => {
            nodeElements.style('opacity', 1);
            linkElements.style('opacity', 1);
            closeControlPanel();
        });

        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.1).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            // Mantener posici√≥n fija despu√©s de arrastrar
            // d.fx = null;
            // d.fy = null;
        }

        function focusGroup(groupId) {
            // Actualizar UI
            document.querySelectorAll('.group-item').forEach(item => {
                item.classList.remove('active');
            });
            event.target.closest('.group-item').classList.add('active');
            
            // Highlight servicios del grupo
            const groupServices = topologyData.groups.find(g => g.id === groupId)?.services || [];
            const serviceIds = groupServices.map(s => s.id);
            
            nodeElements.style('opacity', n => {
                return serviceIds.includes(n.id) ? 1 : 0.2;
            });

            linkElements.style('opacity', l => {
                return serviceIds.includes(l.source.id) || serviceIds.includes(l.target.id) ? 1 : 0.1;
            });
        }

        function refreshTopology() {
            loadTopology();
        }

        // Auto-refresh cada 5 segundos (solo estados, no recrea gr√°fico)
        setInterval(refreshTopology, 5000);

        // Cargar al inicio
        loadTopology();

        // Responsive - redimensionar canvas
        window.addEventListener('resize', () => {
            if (simulation) {
                const svg = d3.select('#topology-svg');
                const width = svg.node().getBoundingClientRect().width;
                const height = svg.node().getBoundingClientRect().height;
                
                simulation.force('center', d3.forceCenter(width / 2, height / 2));
                simulation.alpha(0.3).restart();
            }
        });

        // ============= WebSocket para tr√°fico en tiempo real =============
        
        function connectWebSocket() {
            ws = new WebSocket(WS_URL);
            
            ws.onopen = () => {
                console.log('‚úÖ WebSocket conectado - Monitoreando tr√°fico en tiempo real');
            };
            
            ws.onmessage = (event) => {
                const trafficEvent = JSON.parse(event.data);
                handleTrafficEvent(trafficEvent);
            };
            
            ws.onerror = (error) => {
                console.error('‚ùå WebSocket error:', error);
            };
            
            ws.onclose = () => {
                console.log('üîå WebSocket desconectado - Reconectando en 3s...');
                setTimeout(connectWebSocket, 3000);
            };
        }

        function handleTrafficEvent(event) {
            console.log('üö¶ Tr√°fico en tiempo real:', event.method, event.path, '‚Üí', event.status);
            
            // Filtrar solo auto-referencias (servicio llam√°ndose a s√≠ mismo)
            if (event.from === event.to) {
                return; // Ignorar tr√°fico del tipo "service ‚Üí service"
            }
            
            // Buscar o crear nodos
            let fromNode = nodes.find(n => n.name === event.from || n.name.includes(event.from) || event.from.includes(n.name));
            let toNode = nodes.find(n => n.name === event.to || n.name.includes(event.to) || event.to.includes(n.name));
            
            // Crear nodos temporales si no existen
            if (!fromNode) {
                fromNode = createTemporaryNode(event.from);
            }
            if (!toNode) {
                toNode = createTemporaryNode(event.to);
            }
            
            // Buscar o crear enlace
            let link = links.find(l => 
                (l.source.id === fromNode.id && l.target.id === toNode.id) ||
                (l.target.id === fromNode.id && l.source.id === toNode.id)
            );
            
            if (!link) {
                link = createTemporaryLink(fromNode, toNode);
            }
            
            if (link) {
                animateRealTraffic(link, event);
            }
        }

        function createTemporaryNode(serviceName) {
            if (!simulation) {
                console.warn('‚ö†Ô∏è  Simulaci√≥n no inicializada, no se puede crear nodo temporal');
                return null;
            }
            
            const svg = d3.select('#topology-svg');
            const width = svg.node().getBoundingClientRect().width;
            const height = svg.node().getBoundingClientRect().height;
            
            const tempNode = {
                id: `temp-${serviceName}-${Date.now()}`,
                name: serviceName,
                status: 'unknown',
                icon: 'üåê',
                group: 'external',
                groupIndex: 999,
                networks: [],
                is_remote: false,
                is_temporary: true,
                x: width / 2 + (Math.random() - 0.5) * 200,
                y: height / 2 + (Math.random() - 0.5) * 200,
                vx: 0,
                vy: 0
            };
            
            nodes.push(tempNode);
            
            // Actualizar la simulaci√≥n con el nuevo nodo
            simulation.nodes(nodes);
            simulation.alpha(0.3).restart();
            
            // Agregar visualmente al SVG como parte de nodeElements
            const nodeGroup = d3.select(nodeElements.node().parentNode);
            
            const newNode = nodeGroup.append('g')
                .datum(tempNode)
                .attr('class', 'node temp-node')
                .attr('transform', `translate(${tempNode.x},${tempNode.y})`)
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));
            
            newNode.append('circle')
                .attr('class', 'node-circle node-unknown')
                .attr('r', 40)
                .style('opacity', 0.6)
                .style('stroke-dasharray', '5,5');
            
            newNode.append('text')
                .attr('class', 'node-icon')
                .attr('y', 8)
                .text('üåê');
            
            newNode.append('text')
                .attr('class', 'node-label')
                .attr('y', 60)
                .text(serviceName);
            
            // Actualizar la selecci√≥n de nodeElements para incluir el nuevo nodo
            nodeElements = d3.selectAll('.node');
            
            console.log(`üÜï Nodo temporal creado: ${serviceName}`);
            
            // Auto-eliminar despu√©s de 5 minutos
            setTimeout(() => removeTemporaryNode(tempNode.id), 300000);
            
            return tempNode;
        }
        
        function createTemporaryLink(fromNode, toNode) {
            if (!simulation) {
                console.warn('‚ö†Ô∏è  Simulaci√≥n no inicializada, no se puede crear link temporal');
                return null;
            }
            
            const tempLink = {
                source: fromNode,
                target: toNode,
                network: 'temporary',
                is_temporary: true
            };
            
            links.push(tempLink);
            
            // Actualizar la simulaci√≥n con el nuevo link
            simulation.force('link').links(links);
            simulation.alpha(0.1).restart();
            
            // Agregar visualmente al SVG (al grupo de links correcto)
            if (!linkElements || linkElements.empty()) {
                console.warn('‚ö†Ô∏è  linkElements no disponible');
                return tempLink;
            }
            
            const newLinkGroup = d3.select(linkElements.node().parentNode)
                .insert('g', ':first-child')
                .datum(tempLink)
                .attr('class', 'link-group temp-link');
            
            newLinkGroup.append('path')
                .attr('class', 'link')
                .attr('stroke', '#00d4ff')
                .attr('stroke-width', 3)
                .attr('stroke-opacity', 0.3)
                .attr('stroke-dasharray', '5,5')
                .attr('fill', 'none');
            
            newLinkGroup.append('circle')
                .attr('class', 'link-particle')
                .attr('r', 4)
                .attr('fill', '#00d4ff')
                .attr('opacity', 0)
                .style('filter', 'drop-shadow(0 0 4px #00d4ff)');
            
            console.log(`üîó Link temporal creado: ${fromNode.name} ‚Üî ${toNode.name}`);
            
            return tempLink;
        }
        
        function removeTemporaryNode(nodeId) {
            const index = nodes.findIndex(n => n.id === nodeId);
            if (index !== -1 && nodes[index].is_temporary) {
                console.log(`üóëÔ∏è  Eliminando nodo temporal: ${nodes[index].name}`);
                nodes.splice(index, 1);
                
                // Eliminar links asociados
                links = links.filter(l => 
                    (typeof l.source === 'object' ? l.source.id : l.source) !== nodeId && 
                    (typeof l.target === 'object' ? l.target.id : l.target) !== nodeId
                );
                
                // Actualizar simulaci√≥n
                if (simulation) {
                    simulation.nodes(nodes);
                    simulation.force('link').links(links);
                    simulation.alpha(0.1).restart();
                }
                
                // Refrescar visualizaci√≥n
                d3.selectAll('.temp-node').filter(d => d.id === nodeId).remove();
                d3.selectAll('.temp-link').filter(d => 
                    (d.source.id === nodeId || d.target.id === nodeId)
                ).remove();
            }
        }
        
        function updateLinkPositions() {
            d3.selectAll('.link-group path').attr('d', d => {
                const source = typeof d.source === 'object' ? d.source : nodes.find(n => n.id === d.source);
                const target = typeof d.target === 'object' ? d.target : nodes.find(n => n.id === d.target);
                if (!source || !target || !source.x || !target.x) return '';
                return `M ${source.x} ${source.y} L ${target.x} ${target.y}`;
            });
        }

        function animateRealTraffic(link, event) {
            // Determinar color seg√∫n status code
            let color = '#00d4ff'; // default
            if (event.status >= 200 && event.status < 300) color = '#10b981'; // success
            else if (event.status >= 400 && event.status < 500) color = '#f59e0b'; // warning
            else if (event.status >= 500) color = '#ef4444'; // error
            
            // Encontrar el grupo del link
            const linkElement = d3.selectAll('.link-group')
                .filter(d => d === link);
            
            if (!linkElement.empty()) {
                // Crear part√≠cula temporal
                const particle = linkElement.append('circle')
                    .attr('class', 'real-traffic-particle')
                    .attr('r', 6)
                    .attr('fill', color)
                    .style('filter', `drop-shadow(0 0 8px ${color})`)
                    .attr('opacity', 1);
                
                // Animar desde source a target
                const duration = Math.max(800, Math.min(event.duration * 2, 3000));
                
                particle.transition()
                    .duration(duration)
                    .ease(d3.easeLinear)
                    .attrTween('transform', function() {
                        return function(t) {
                            const source = link.source;
                            const target = link.target;
                            const x = source.x + (target.x - source.x) * t;
                            const y = source.y + (target.y - source.y) * t;
                            return `translate(${x},${y})`;
                        };
                    })
                    .on('end', function() {
                        // Pulso en el nodo destino
                        const targetNode = nodeElements.filter(d => d.id === link.target.id);
                        targetNode.select('circle')
                            .transition()
                            .duration(200)
                            .attr('r', 50)
                            .transition()
                            .duration(200)
                            .attr('r', 45);
                        
                        // Remover part√≠cula
                        particle.remove();
                    });
                
                // Hacer el enlace m√°s brillante temporalmente
                linkElement.select('path')
                    .transition()
                    .duration(200)
                    .attr('stroke', color)
                    .attr('stroke-opacity', 0.9)
                    .attr('stroke-width', 5)
                    .transition()
                    .duration(1000)
                    .attr('stroke', '#00d4ff')
                    .attr('stroke-opacity', 0.4)
                    .attr('stroke-width', 3);
            }
        }

        // Conectar WebSocket al cargar
        connectWebSocket();
    </script>
</body>
</html>
