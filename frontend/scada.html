<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>kuNNA - SCADA Monitor</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        :root {
            --bg-primary: #0f0f23;
            --bg-secondary: #1a1a2e;
            --bg-card: #16213e;
            --accent-primary: #00d4ff;
            --accent-secondary: #a855f7;
            --text-primary: #ffffff;
            --text-secondary: #94a3b8;
            --border-color: #2d3748;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow: hidden;
        }

        .toolbar {
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            padding: 16px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .toolbar h1 {
            font-size: 1.8em;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .toolbar-actions {
            display: flex;
            gap: 12px;
        }

        .btn {
            padding: 10px 20px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            background: var(--bg-card);
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'Inter', sans-serif;
            font-weight: 500;
            text-decoration: none;
        }

        .btn:hover {
            background: var(--bg-secondary);
            border-color: var(--accent-primary);
            transform: translateY(-2px);
        }

        .stats {
            display: flex;
            gap: 12px;
        }

        .stat {
            padding: 8px 16px;
            background: var(--bg-card);
            border-radius: 8px;
            font-size: 0.9em;
        }

        .stat-value {
            font-weight: 700;
            color: var(--accent-primary);
        }

        .container {
            display: flex;
            height: calc(100vh - 70px);
        }

        .sidebar {
            width: 300px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            padding: 20px;
            overflow-y: auto;
        }

        .sidebar h2 {
            font-size: 1.2em;
            margin-bottom: 16px;
            color: var(--text-secondary);
        }

        .group-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .group-item {
            padding: 12px;
            background: var(--bg-card);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.3s;
        }

        .group-item:hover {
            border-color: var(--accent-primary);
            transform: translateX(4px);
        }

        .group-item.active {
            border-color: var(--accent-primary);
            background: var(--bg-primary);
        }

        .group-name {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .group-services {
            font-size: 0.85em;
            color: var(--text-secondary);
        }

        .canvas {
            flex: 1;
            position: relative;
            background: var(--bg-primary);
            background-image: 
                repeating-linear-gradient(0deg, transparent, transparent 49px, var(--border-color) 49px, var(--border-color) 50px),
                repeating-linear-gradient(90deg, transparent, transparent 49px, var(--border-color) 49px, var(--border-color) 50px);
        }

        #topology-svg {
            width: 100%;
            height: 100%;
        }

        .node {
            cursor: move;
        }

        .node-circle {
            transition: all 0.3s;
        }

        .node:hover .node-circle {
            filter: brightness(1.3);
            r: 45;
        }

        .node-running {
            fill: var(--success);
            filter: drop-shadow(0 0 10px var(--success));
        }

        .node-stopped {
            fill: var(--danger);
            filter: drop-shadow(0 0 10px var(--danger));
        }

        .node-paused {
            fill: var(--warning);
            filter: drop-shadow(0 0 10px var(--warning));
        }

        .node-label {
            fill: var(--text-primary);
            font-size: 12px;
            font-weight: 600;
            text-anchor: middle;
            pointer-events: none;
        }

        .node-icon {
            font-size: 24px;
            text-anchor: middle;
            pointer-events: none;
        }

        .link {
            stroke: var(--accent-primary);
            stroke-width: 3;
            stroke-opacity: 0.4;
            fill: none;
            transition: stroke-opacity 0.3s;
        }

        .link-particle {
            pointer-events: none;
        }

        .status-badge {
            stroke: var(--bg-card);
            stroke-width: 2;
            transition: fill 0.5s;
        }

        .node {
            cursor: move;
            transition: opacity 0.3s;
        }

        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 16px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--accent-primary);
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="toolbar">
        <h1>üéØ kuNNA SCADA Monitor</h1>
        <div class="stats">
            <div class="stat">
                Total: <span class="stat-value" id="total-services">0</span>
            </div>
            <div class="stat">
                Activos: <span class="stat-value" id="active-services">0</span>
            </div>
            <div class="stat">
                Grupos: <span class="stat-value" id="total-groups">0</span>
            </div>
        </div>
        <div class="toolbar-actions">
            <a href="/" class="btn">üìä Dashboard</a>
            <a href="/servers.html" class="btn" style="background: linear-gradient(135deg, #7c3aed, #a855f7);">üñ•Ô∏è Servidores</a>
            <button class="btn" onclick="refreshTopology()">üîÑ Actualizar</button>
        </div>
    </div>

    <div class="container">
        <div class="sidebar">
            <h2>Grupos de Aplicaciones</h2>
            <div class="group-list" id="group-list">
                <!-- Se llena din√°micamente -->
            </div>
        </div>

        <div class="canvas">
            <svg id="topology-svg"></svg>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background: var(--success);"></div>
                    <span>Running</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: var(--danger);"></div>
                    <span>Stopped</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: var(--warning);"></div>
                    <span>Paused</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        const API_URL = 'http://localhost:8000/api';
        const WS_URL = 'ws://localhost:8000/ws/traffic';
        let topologyData = null;
        let simulation = null;
        let svg = null;
        let nodes = [];
        let links = [];
        let nodeElements = null;
        let linkElements = null;
        let ws = null;
        let trafficQueue = [];

        async function loadTopology() {
            try {
                const response = await fetch(`${API_URL}/topology`);
                const newData = await response.json();
                
                // Actualizar estad√≠sticas
                document.getElementById('total-services').textContent = newData.total_services;
                document.getElementById('active-services').textContent = newData.active_services;
                document.getElementById('total-groups').textContent = newData.groups.length;
                
                // Primera carga - crear gr√°fico
                if (!topologyData) {
                    topologyData = newData;
                    renderGroups();
                    initializeTopology();
                } else {
                    // Solo actualizar estados sin recrear
                    updateNodeStates(newData);
                    topologyData = newData;
                }
            } catch (error) {
                console.error('Error loading topology:', error);
            }
        }

        function renderGroups() {
            const groupList = document.getElementById('group-list');
            groupList.innerHTML = topologyData.groups.map((group, index) => `
                <div class="group-item ${index === 0 ? 'active' : ''}" onclick="focusGroup('${group.id}')">
                    <div class="group-name">${group.name}</div>
                    <div class="group-services">${group.services.length} servicios</div>
                </div>
            `).join('');
        }

        function updateNodeStates(newData) {
            if (!nodeElements) return;

            // Crear mapa de estados nuevos
            const statusMap = {};
            newData.groups.forEach(group => {
                group.services.forEach(service => {
                    statusMap[service.id] = service.status;
                });
            });

            // Actualizar clases de estado en los c√≠rculos
            nodeElements.selectAll('circle')
                .attr('class', d => {
                    const newStatus = statusMap[d.id] || d.status;
                    d.status = newStatus; // Actualizar el dato
                    return `node-circle node-${newStatus}`;
                });
        }

        function initializeTopology() {
            svg = d3.select('#topology-svg');
            const width = svg.node().getBoundingClientRect().width;
            const height = svg.node().getBoundingClientRect().height;

            svg.selectAll('*').remove();

            // Preparar datos para D3
            nodes = [];
            links = [];

            // Crear nodos por servicio
            topologyData.groups.forEach((group, groupIndex) => {
                group.services.forEach((service, serviceIndex) => {
                    nodes.push({
                        id: service.id,
                        name: service.name,
                        status: service.status,
                        icon: service.icon,
                        group: group.id,
                        groupIndex: groupIndex,
                        networks: service.networks
                    });
                });
            });

            // Crear enlaces SOLO entre servicios que comparten red
            topologyData.connections.forEach(conn => {
                links.push({
                    source: conn.source,
                    target: conn.target,
                    network: conn.network
                });
            });

            // Crear simulaci√≥n de fuerza con posiciones iniciales fijas
            simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(200))
                .force('charge', d3.forceManyBody().strength(-500))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(70))
                .force('x', d3.forceX(width / 2).strength(0.05))
                .force('y', d3.forceY(height / 2).strength(0.05));

            // Dibujar enlaces primero (debajo de los nodos)
            const linkGroup = svg.append('g');
            linkElements = linkGroup.selectAll('g')
                .data(links)
                .enter().append('g')
                .attr('class', 'link-group');

            // L√≠nea base del enlace
            linkElements.append('path')
                .attr('class', 'link')
                .attr('stroke', '#00d4ff')
                .attr('stroke-width', 3)
                .attr('stroke-opacity', 0.4)
                .attr('fill', 'none');

            // C√≠rculo animado que viaja por el enlace (petici√≥n simulada - ser√° reemplazado por real)
            linkElements.append('circle')
                .attr('class', 'link-particle')
                .attr('r', 4)
                .attr('fill', '#00d4ff')
                .attr('opacity', 0)
                .style('filter', 'drop-shadow(0 0 4px #00d4ff)');

            // NO iniciar animaci√≥n simulada - solo tr√°fico real
            // startParticleAnimation(); // ‚Üê DESHABILITADO

            // Dibujar nodos
            nodeElements = svg.append('g')
                .selectAll('g')
                .data(nodes)
                .enter().append('g')
                .attr('class', 'node')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended))
                .on('click', onNodeClick);

            // C√≠rculos de nodos con estado
            nodeElements.append('circle')
                .attr('class', d => `node-circle node-${d.status}`)
                .attr('r', 45);

            // Iconos
            nodeElements.append('text')
                .attr('class', 'node-icon')
                .attr('dy', 10)
                .style('font-size', '28px')
                .text(d => d.icon);

            // Etiquetas
            nodeElements.append('text')
                .attr('class', 'node-label')
                .attr('dy', 70)
                .text(d => d.name.length > 15 ? d.name.substring(0, 15) + '...' : d.name);

            // Badge de estado
            nodeElements.append('circle')
                .attr('class', 'status-badge')
                .attr('cx', 30)
                .attr('cy', -30)
                .attr('r', 8)
                .attr('fill', d => getStatusColor(d.status));

            // Actualizar posiciones en cada tick
            simulation.on('tick', updatePositions);

            // Detener simulaci√≥n despu√©s de un tiempo para estabilizar
            setTimeout(() => {
                simulation.alpha(0);
            }, 3000);
        }

        function startParticleAnimation() {
            function animate() {
                linkElements.selectAll('.link-particle')
                    .attr('opacity', 0)
                    .transition()
                    .duration(0)
                    .attr('opacity', 1)
                    .transition()
                    .duration(2000)
                    .ease(d3.easeLinear)
                    .attrTween('transform', function(d) {
                        return function(t) {
                            const source = d.source;
                            const target = d.target;
                            if (!source || !target) return '';
                            
                            const x = source.x + (target.x - source.x) * t;
                            const y = source.y + (target.y - source.y) * t;
                            return `translate(${x},${y})`;
                        };
                    })
                    .transition()
                    .duration(0)
                    .attr('opacity', 0);
                
                setTimeout(animate, 2500);
            }
            
            // Iniciar con delay aleatorio para cada enlace
            linkElements.each(function(d, i) {
                setTimeout(() => {
                    d3.select(this).select('.link-particle').call(() => animate());
                }, i * 300);
            });
        }

        function updatePositions() {
            // Actualizar enlaces
            linkElements.select('path')
                .attr('d', d => {
                    if (!d.source || !d.target) return '';
                    const dx = d.target.x - d.source.x;
                    const dy = d.target.y - d.source.y;
                    const dr = Math.sqrt(dx * dx + dy * dy) * 1.5;
                    return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
                });

            // Actualizar nodos
            nodeElements.attr('transform', d => `translate(${d.x},${d.y})`);
        }

        function getStatusColor(status) {
            const colors = {
                'running': '#10b981',
                'exited': '#ef4444',
                'paused': '#f59e0b'
            };
            return colors[status] || '#6b7280';
        }

        function onNodeClick(event, d) {
            event.stopPropagation();
            
            // Highlight del nodo y sus conexiones
            nodeElements.style('opacity', n => {
                return n === d || isConnected(n, d) ? 1 : 0.3;
            });

            linkElements.style('opacity', l => {
                return l.source === d || l.target === d ? 1 : 0.1;
            });

            // Mostrar info
            console.log('Service:', d.name, 'Status:', d.status, 'Networks:', d.networks);
        }

        function isConnected(node1, node2) {
            return links.some(l => 
                (l.source.id === node1.id && l.target.id === node2.id) ||
                (l.source.id === node2.id && l.target.id === node1.id)
            );
        }

        // Click en canvas para quitar highlight
        d3.select('#topology-svg').on('click', () => {
            nodeElements.style('opacity', 1);
            linkElements.style('opacity', 1);
        });

        function dragstarted(event, d) {
            if (!event.active) simulation.alphaTarget(0.1).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            // Mantener posici√≥n fija despu√©s de arrastrar
            // d.fx = null;
            // d.fy = null;
        }

        function focusGroup(groupId) {
            // Actualizar UI
            document.querySelectorAll('.group-item').forEach(item => {
                item.classList.remove('active');
            });
            event.target.closest('.group-item').classList.add('active');
            
            // Highlight servicios del grupo
            const groupServices = topologyData.groups.find(g => g.id === groupId)?.services || [];
            const serviceIds = groupServices.map(s => s.id);
            
            nodeElements.style('opacity', n => {
                return serviceIds.includes(n.id) ? 1 : 0.2;
            });

            linkElements.style('opacity', l => {
                return serviceIds.includes(l.source.id) || serviceIds.includes(l.target.id) ? 1 : 0.1;
            });
        }

        function refreshTopology() {
            loadTopology();
        }

        // Auto-refresh cada 5 segundos (solo estados, no recrea gr√°fico)
        setInterval(refreshTopology, 5000);

        // Cargar al inicio
        loadTopology();

        // Responsive - redimensionar canvas
        window.addEventListener('resize', () => {
            if (simulation) {
                const svg = d3.select('#topology-svg');
                const width = svg.node().getBoundingClientRect().width;
                const height = svg.node().getBoundingClientRect().height;
                
                simulation.force('center', d3.forceCenter(width / 2, height / 2));
                simulation.alpha(0.3).restart();
            }
        });

        // ============= WebSocket para tr√°fico en tiempo real =============
        
        function connectWebSocket() {
            ws = new WebSocket(WS_URL);
            
            ws.onopen = () => {
                console.log('‚úÖ WebSocket conectado - Monitoreando tr√°fico en tiempo real');
            };
            
            ws.onmessage = (event) => {
                const trafficEvent = JSON.parse(event.data);
                handleTrafficEvent(trafficEvent);
            };
            
            ws.onerror = (error) => {
                console.error('‚ùå WebSocket error:', error);
            };
            
            ws.onclose = () => {
                console.log('üîå WebSocket desconectado - Reconectando en 3s...');
                setTimeout(connectWebSocket, 3000);
            };
        }

        function handleTrafficEvent(event) {
            console.log('üö¶ Tr√°fico en tiempo real:', event.method, event.path, '‚Üí', event.status);
            
            // Encontrar el enlace correspondiente
            const link = findLinkByServiceNames(event.from, event.to);
            
            if (link) {
                animateRealTraffic(link, event);
            }
        }

        function findLinkByServiceNames(from, to) {
            // Si "from" es "external", buscar cualquier link que apunte al servicio "to"
            if (from === 'external') {
                const toNode = nodes.find(n => n.name === to || to.includes(n.name));
                
                if (toNode && links.length > 0) {
                    return links.find(l => 
                        l.source.id === toNode.id || l.target.id === toNode.id
                    );
                }
            }
            
            // Convertir nombres de servicios a IDs
            const fromNode = nodes.find(n => n.name === from || from.includes(n.name));
            const toNode = nodes.find(n => n.name === to || to.includes(n.name));
            
            if (!fromNode || !toNode) return null;
            
            return links.find(l => 
                (l.source.id === fromNode.id && l.target.id === toNode.id) ||
                (l.source.id === toNode.id && l.target.id === fromNode.id)
            );
        }

        function animateRealTraffic(link, event) {
            // Determinar color seg√∫n status code
            let color = '#00d4ff'; // default
            if (event.status >= 200 && event.status < 300) color = '#10b981'; // success
            else if (event.status >= 400 && event.status < 500) color = '#f59e0b'; // warning
            else if (event.status >= 500) color = '#ef4444'; // error
            
            // Encontrar el grupo del link
            const linkElement = d3.selectAll('.link-group')
                .filter(d => d === link);
            
            if (!linkElement.empty()) {
                // Crear part√≠cula temporal
                const particle = linkElement.append('circle')
                    .attr('class', 'real-traffic-particle')
                    .attr('r', 6)
                    .attr('fill', color)
                    .style('filter', `drop-shadow(0 0 8px ${color})`)
                    .attr('opacity', 1);
                
                // Animar desde source a target
                const duration = Math.max(800, Math.min(event.duration * 2, 3000));
                
                particle.transition()
                    .duration(duration)
                    .ease(d3.easeLinear)
                    .attrTween('transform', function() {
                        return function(t) {
                            const source = link.source;
                            const target = link.target;
                            const x = source.x + (target.x - source.x) * t;
                            const y = source.y + (target.y - source.y) * t;
                            return `translate(${x},${y})`;
                        };
                    })
                    .on('end', function() {
                        // Pulso en el nodo destino
                        const targetNode = nodeElements.filter(d => d.id === link.target.id);
                        targetNode.select('circle')
                            .transition()
                            .duration(200)
                            .attr('r', 50)
                            .transition()
                            .duration(200)
                            .attr('r', 45);
                        
                        // Remover part√≠cula
                        particle.remove();
                    });
                
                // Hacer el enlace m√°s brillante temporalmente
                linkElement.select('path')
                    .transition()
                    .duration(200)
                    .attr('stroke', color)
                    .attr('stroke-opacity', 0.9)
                    .attr('stroke-width', 5)
                    .transition()
                    .duration(1000)
                    .attr('stroke', '#00d4ff')
                    .attr('stroke-opacity', 0.4)
                    .attr('stroke-width', 3);
            }
        }

        // Conectar WebSocket al cargar
        connectWebSocket();
    </script>
</body>
</html>
